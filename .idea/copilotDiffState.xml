<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Backend/.scripts/Deploy/servicesExtern/install/install-cert-manager.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Backend/.scripts/Deploy/servicesExtern/install/install-cert-manager.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;&#10;set -euo pipefail&#10;&#10;SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;&#10;BACKEND_ROOT_DIR=&quot;$SCRIPT_DIR/../../../..&quot;&#10;VAULT_OTHER_DATA_DIR=$BACKEND_ROOT_DIR/.data/other/vault&#10;VAULT_TMP_DATA_DIR=$BACKEND_ROOT_DIR/.data/tmp/vault&#10;CA_CERT_FILE=$VAULT_OTHER_DATA_DIR/ca-cert.pem&#10;&#10;source &quot;$BACKEND_ROOT_DIR/.scripts/functions/logs.sh&quot;&#10;source &quot;$BACKEND_ROOT_DIR/.scripts/functions/env.sh&quot;&#10;&#10;CERT_MANAGER_NAMESPACE=&quot;cert-manager&quot;&#10;CERT_MANAGER_VERSION=&quot;v1.13.3&quot;&#10;&#10;# 1. Install/Upgrade cert-manager CRDs first&#10;log &quot;Applying cert-manager CRDs...&quot;&#10;kubectl apply -f &quot;https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.crds.yaml&quot;&#10;&#10;# 2. Install cert-manager via Helm&#10;log &quot;Adding Jetstack Helm repository...&quot;&#10;helm repo add jetstack https://charts.jetstack.io&#10;helm repo update&#10;&#10;log &quot;Installing cert-manager...&quot;&#10;helm install \&#10;  cert-manager jetstack/cert-manager \&#10;  --namespace &quot;${CERT_MANAGER_NAMESPACE}&quot; \&#10;  --create-namespace \&#10;  --version ${CERT_MANAGER_VERSION} \&#10;  --set installCRDs=false # CRDs are installed manually above&#10;&#10;log_wait &quot;Waiting for cert-manager webhook to be ready...&quot;&#10;kubectl wait --for=condition=available --timeout=600s deployment/cert-manager-webhook -n &quot;${CERT_MANAGER_NAMESPACE}&quot;&#10;&#10;log &quot;Applying ClusterRole for cert-manager to create ServiceAccount tokens...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -f -&#10;apiVersion: rbac.authorization.k8s.io/v1&#10;kind: ClusterRole&#10;metadata:&#10;  name: cert-manager-controller-vault-issuer&#10;rules:&#10;- apiGroups: [&quot;&quot;]&#10;  resources: [&quot;serviceaccounts/token&quot;]&#10;  verbs: [&quot;create&quot;]&#10;---&#10;apiVersion: rbac.authorization.k8s.io/v1&#10;kind: ClusterRoleBinding&#10;metadata:&#10;  name: cert-manager-controller-vault-issuer&#10;roleRef:&#10;  apiGroup: rbac.authorization.k8s.io&#10;  kind: ClusterRole&#10;  name: cert-manager-controller-vault-issuer&#10;subjects:&#10;- kind: ServiceAccount&#10;  name: cert-manager&#10;  namespace: cert-manager&#10;EOF&#10;&#10;ISSUER_NAME=&quot;vault-issuer&quot;&#10;VAULT_SERVER=&quot;http://pki-vault.vault.svc.cluster.local:8200&quot;&#10;VAULT_PATH=&quot;pki/sign/cert-manager&quot;&#10;VAULT_ROLE=&quot;cert-manager&quot;&#10;TLS_SECRET_NAME=&quot;vault-ca-secret&quot;&#10;&#10;# 3. ServiceAccount anlegen&#10;log &quot;Creating ServiceAccount for Vault Issuer...&quot;&#10;kubectl apply -n &quot;${CERT_MANAGER_NAMESPACE}&quot; -f - &lt;&lt;EOF&#10;apiVersion: v1&#10;kind: ServiceAccount&#10;metadata:&#10;  name: ${ISSUER_NAME}&#10;  namespace: ${CERT_MANAGER_NAMESPACE}&#10;EOF&#10;&#10;# 4. TLS Secret nur mit der Vault CA anlegen&#10;log &quot;Creating TLS secret for Vault CA...&quot;&#10;if [ ! -f &quot;$CA_CERT_FILE&quot; ]; then&#10;    log_error &quot;Vault CA file not found at $CA_CERT_FILE&quot;&#10;    exit 1&#10;fi&#10;kubectl create secret generic ${TLS_SECRET_NAME} \&#10;  --namespace ${CERT_MANAGER_NAMESPACE} \&#10;  --from-file=ca.crt=${CA_CERT_FILE} \&#10;  --dry-run=client -o yaml | kubectl apply -f -&#10;&#10;# 5. cert-manager Issuer YAML bereitstellen und anwenden&#10;log &quot;Creating cert-manager Vault Issuer...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -n ${CERT_MANAGER_NAMESPACE} -f -&#10;apiVersion: cert-manager.io/v1&#10;kind: ClusterIssuer&#10;metadata:&#10;  name: ${ISSUER_NAME}&#10;spec:&#10;  vault:&#10;    server: ${VAULT_SERVER}&#10;    path: ${VAULT_PATH}&#10;        role: ${VAULT_ROLE}&#10;        serviceAccountRef:&#10;          name: ${ISSUER_NAME}&#10;EOF&#10;&#10;log &quot;cert-manager Issuer '${ISSUER_NAME}' created in namespace '${CERT_MANAGER_NAMESPACE}'.&quot;&#10;log &quot;cert-manager Issuer '${ISSUER_NAME}' created in namespace '${CERT_MANAGER_NAMESPACE}'.&quot;&#10;log &quot;cert-manager Issuer '${ISSUER_NAME}' created in namespace '${CERT_MANAGER_NAMESPACE}'.&quot;&#10;log &quot;cert-manager Issuer '${ISSUER_NAME}' created in namespace '${CERT_MANAGER_NAMESPACE}'.&quot;&#10;# 6. Request a sample certificate&#10;# 6. Request a sample certificate&#10;CERT_NAME=&quot;example-certificate&quot;&#10;CERT_SECRET_NAME=&quot;test-tls&quot;&#10;CERT_COMMON_NAME=&quot;test.ventra.cluster&quot;&#10;# 6. Request a sample certificate&#10;log &quot;Requesting a sample certificate '${CERT_NAME}'...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -n ${CERT_MANAGER_NAMESPACE} -f -&#10;&#10;kind: Certificate&#10;cat &lt;&lt;EOF | kubectl apply -n ${CERT_MANAGER_NAMESPACE} -f -&#10;  name: ${CERT_NAME}&#10;  namespace: ${CERT_MANAGER_NAMESPACE}&#10;kind: Certificate&#10;  secretName: ${CERT_SECRET_NAME}&#10;  issuerRef:&#10;    name: ${ISSUER_NAME}&#10;    kind: ClusterIssuer&#10;  commonName: ${CERT_COMMON_NAME}&#10;  dnsNames:&#10;  - ${CERT_COMMON_NAME}&#10;  privateKey:&#10;      algorithm: RSA&#10;      size: 4096&#10;  - ${CERT_COMMON_NAME}&#10;  privateKey:&#10;log_wait &quot;Waiting for certificate '${CERT_NAME}' to be issued...&quot;&#10;kubectl wait --for=condition=Ready=True --timeout=120s \&#10;  certificate/${CERT_NAME} -n ${CERT_MANAGER_NAMESPACE}&#10;&#10;log &quot;Certificate '${CERT_NAME}' issued successfully.&quot;&#10;&#10;log &quot;Saving certificate and key to files in '${VAULT_TMP_DATA_DIR}'...&quot;&#10;mkdir -p &quot;${VAULT_TMP_DATA_DIR}&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.crt}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.crt&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.key}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.key&quot;&#10;&#10;log &quot;Certificate and key saved to '${VAULT_TMP_DATA_DIR}/test-tls.crt' and '${VAULT_TMP_DATA_DIR}/test-tls.key'.&quot;&#10;      size: 4096&#10;  - ${CERT_COMMON_NAME}&#10;  privateKey:&#10;log_wait &quot;Waiting for certificate '${CERT_NAME}' to be issued...&quot;&#10;kubectl wait --for=condition=Ready=True --timeout=120s \&#10;  certificate/${CERT_NAME} -n ${CERT_MANAGER_NAMESPACE}&#10;&#10;log &quot;Certificate '${CERT_NAME}' issued successfully.&quot;&#10;&#10;log &quot;Saving certificate and key to files in '${VAULT_TMP_DATA_DIR}'...&quot;&#10;mkdir -p &quot;${VAULT_TMP_DATA_DIR}&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.crt}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.crt&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.key}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.key&quot;&#10;&#10;log &quot;Certificate and key saved to '${VAULT_TMP_DATA_DIR}/test-tls.crt' and '${VAULT_TMP_DATA_DIR}/test-tls.key'.&quot;&#10;      size: 4096&#10;  - ${CERT_COMMON_NAME}&#10;  privateKey:&#10;log_wait &quot;Waiting for certificate '${CERT_NAME}' to be issued...&quot;&#10;kubectl wait --for=condition=Ready=True --timeout=120s \&#10;  certificate/${CERT_NAME} -n ${CERT_MANAGER_NAMESPACE}&#10;&#10;log &quot;Certificate '${CERT_NAME}' issued successfully.&quot;&#10;&#10;log &quot;Saving certificate and key to files in '${VAULT_TMP_DATA_DIR}'...&quot;&#10;mkdir -p &quot;${VAULT_TMP_DATA_DIR}&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.crt}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.crt&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.key}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.key&quot;&#10;&#10;log &quot;Certificate and key saved to '${VAULT_TMP_DATA_DIR}/test-tls.crt' and '${VAULT_TMP_DATA_DIR}/test-tls.key'.&quot;&#10;      size: 4096&#10;EOF&#10;&#10;log_wait &quot;Waiting for certificate '${CERT_NAME}' to be issued...&quot;&#10;kubectl wait --for=condition=Ready=True --timeout=120s \&#10;  certificate/${CERT_NAME} -n ${CERT_MANAGER_NAMESPACE}&#10;&#10;log &quot;Certificate '${CERT_NAME}' issued successfully.&quot;&#10;&#10;log &quot;Saving certificate and key to files in '${VAULT_TMP_DATA_DIR}'...&quot;&#10;mkdir -p &quot;${VAULT_TMP_DATA_DIR}&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.crt}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.crt&quot;&#10;kubectl get secret ${CERT_SECRET_NAME} -n ${CERT_MANAGER_NAMESPACE} -o jsonpath='{.data.tls\.key}' | base64 --decode &gt; &quot;${VAULT_TMP_DATA_DIR}/test-tls.key&quot;&#10;&#10;log &quot;Certificate and key saved to '${VAULT_TMP_DATA_DIR}/test-tls.crt' and '${VAULT_TMP_DATA_DIR}/test-tls.key'.&quot;" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;set -euo pipefail&#10;&#10;SCRIPT_DIR=&quot;$(cd &quot;$(dirname &quot;${BASH_SOURCE[0]}&quot;)&quot; &amp;&amp; pwd)&quot;&#10;BACKEND_ROOT_DIR=&quot;$SCRIPT_DIR/../../../..&quot;&#10;VAULT_OTHER_DATA_DIR=$BACKEND_ROOT_DIR/.data/other/vault&#10;VAULT_TMP_DATA_DIR=$BACKEND_ROOT_DIR/.data/tmp/vault&#10;CA_CERT_FILE=$VAULT_OTHER_DATA_DIR/ca-cert.pem&#10;&#10;source &quot;$BACKEND_ROOT_DIR/.scripts/functions/logs.sh&quot;&#10;source &quot;$BACKEND_ROOT_DIR/.scripts/functions/env.sh&quot;&#10;&#10;CERT_MANAGER_NAMESPACE=&quot;cert-manager&quot;&#10;CERT_MANAGER_VERSION=&quot;v1.13.3&quot;&#10;&#10;# 1. Install/Upgrade cert-manager CRDs first&#10;log &quot;Applying cert-manager CRDs...&quot;&#10;kubectl apply -f &quot;https://github.com/cert-manager/cert-manager/releases/download/${CERT_MANAGER_VERSION}/cert-manager.crds.yaml&quot;&#10;&#10;# 2. Install cert-manager via Helm&#10;log &quot;Adding Jetstack Helm repository...&quot;&#10;helm repo add jetstack https://charts.jetstack.io&#10;helm repo update&#10;&#10;log &quot;Installing cert-manager...&quot;&#10;helm install \&#10;  cert-manager jetstack/cert-manager \&#10;  --namespace &quot;${CERT_MANAGER_NAMESPACE}&quot; \&#10;  --create-namespace \&#10;  --version ${CERT_MANAGER_VERSION} \&#10;  --set installCRDs=false # CRDs are installed manually above&#10;&#10;log_wait &quot;Waiting for cert-manager webhook to be ready...&quot;&#10;kubectl wait --for=condition=available --timeout=600s deployment/cert-manager-webhook -n &quot;${CERT_MANAGER_NAMESPACE}&quot;&#10;&#10;log &quot;Applying ClusterRole for cert-manager to create ServiceAccount tokens...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -f -&#10;apiVersion: rbac.authorization.k8s.io/v1&#10;kind: ClusterRole&#10;metadata:&#10;  name: cert-manager-controller-vault-issuer&#10;rules:&#10;- apiGroups: [&quot;&quot;]&#10;  resources: [&quot;serviceaccounts/token&quot;]&#10;  verbs: [&quot;create&quot;]&#10;---&#10;apiVersion: rbac.authorization.k8s.io/v1&#10;kind: ClusterRoleBinding&#10;metadata:&#10;  name: cert-manager-controller-vault-issuer&#10;roleRef:&#10;  apiGroup: rbac.authorization.k8s.io&#10;  kind: ClusterRole&#10;  name: cert-manager-controller-vault-issuer&#10;subjects:&#10;- kind: ServiceAccount&#10;  name: cert-manager&#10;  namespace: cert-manager&#10;EOF&#10;&#10;ISSUER_NAME=&quot;vault-issuer&quot;&#10;VAULT_SERVER=&quot;http://pki-vault.vault.svc.cluster.local:8200&quot;&#10;VAULT_PATH=&quot;pki/sign/cert-manager&quot;&#10;VAULT_ROLE=&quot;cert-manager&quot;&#10;TLS_SECRET_NAME=&quot;vault-ca-secret&quot;&#10;&#10;# 3. ServiceAccount anlegen&#10;log &quot;Creating ServiceAccount for Vault Issuer...&quot;&#10;kubectl apply -n &quot;${CERT_MANAGER_NAMESPACE}&quot; -f - &lt;&lt;EOF&#10;apiVersion: v1&#10;kind: ServiceAccount&#10;metadata:&#10;  name: ${ISSUER_NAME}&#10;  namespace: ${CERT_MANAGER_NAMESPACE}&#10;EOF&#10;&#10;# 4. TLS Secret nur mit der Vault CA anlegen&#10;log &quot;Creating TLS secret for Vault CA...&quot;&#10;if [ ! -f &quot;$CA_CERT_FILE&quot; ]; then&#10;    log_error &quot;Vault CA file not found at $CA_CERT_FILE&quot;&#10;    exit 1&#10;fi&#10;kubectl create secret generic ${TLS_SECRET_NAME} \&#10;  --namespace ${CERT_MANAGER_NAMESPACE} \&#10;  --from-file=ca.crt=${CA_CERT_FILE} \&#10;  --dry-run=client -o yaml | kubectl apply -f -&#10;&#10;# 5. cert-manager Issuer YAML bereitstellen und anwenden&#10;log &quot;Creating cert-manager Vault Issuer with enhanced mTLS support...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -n ${CERT_MANAGER_NAMESPACE} -f -&#10;apiVersion: cert-manager.io/v1&#10;kind: ClusterIssuer&#10;metadata:&#10;  name: ${ISSUER_NAME}&#10;spec:&#10;  vault:&#10;    server: ${VAULT_SERVER}&#10;    path: ${VAULT_PATH}&#10;    caBundle: $(base64 -w 0 &lt; ${CA_CERT_FILE})&#10;    auth:&#10;      kubernetes:&#10;        mountPath: /v1/auth/kubernetes&#10;        role: ${VAULT_ROLE}&#10;        serviceAccountRef:&#10;          name: ${ISSUER_NAME}&#10;EOF&#10;&#10;log &quot;cert-manager Issuer '${ISSUER_NAME}' created in namespace '${CERT_MANAGER_NAMESPACE}' with CA bundle for mTLS.&quot;&#10;&#10;# 6. Additional ClusterIssuer for internal service communication&#10;log &quot;Creating additional ClusterIssuer for internal mTLS...&quot;&#10;cat &lt;&lt;EOF | kubectl apply -f -&#10;apiVersion: cert-manager.io/v1&#10;kind: ClusterIssuer&#10;metadata:&#10;  name: vault-issuer-internal&#10;spec:&#10;  vault:&#10;    server: ${VAULT_SERVER}&#10;    path: pki/sign/internal-services&#10;    caBundle: $(base64 -w 0 &lt; ${CA_CERT_FILE})&#10;    auth:&#10;      kubernetes:&#10;        mountPath: /v1/auth/kubernetes&#10;        role: ${VAULT_ROLE}&#10;        serviceAccountRef:&#10;          name: ${ISSUER_NAME}&#10;EOF&#10;&#10;log &quot;cert-manager additional Issuer 'vault-issuer-internal' created for internal services in namespace '${CERT_MANAGER_NAMESPACE}'.&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>